ES6
什么是 es6？ ECMAScript 的第六个升级版本
优点： 在不改变原理的基础上，简化了 js 的书写
问题： 兼容性
1， let
什么是 let： 专门替代 var 来声明变量
为什么： 因为 1，var 声明的变量存在提升问题，2，没有块级作用域
何时： 只要声明变量，都用 let
优点：1，阻止了声明提前 2，添加了块级作用域
原理：let 其实就是一个匿名函数自调用，
而且 let 为了双保险，偷偷的将变量改了名字

let 的限制，1，在同级作用域，禁止定义两个同名的变量

2,箭头函数
什么是箭头函数：对普通函数声明的简写
何时： 基本上所有的匿名函数都可以写成箭头函数
箭头函数做了那些事情
1，去掉 function 关键字，在（）和{}之间添加=>
2,如果参数只有一个，小括号可以省略
3，如果函数体只有一条语句，大括号可以省略，如果这条语句是 return，return 要去掉

3,for of
什么是 for of ： 在特定的情况下专门简化 for 循环
遍历一个数组
for（var i = 0;i<arr.length;i++）{
当前元素 arr[i]
}
优点： 可控制遍历的方向，可控制循环的步调
arr.forEach(value=>console.log(value));
局限：不能控制遍历方向，也不能控制循环步调

for(var value of arr){
console.log(value);
}
局限：1，不能获取元素的位置，不能倒叙，不能控制步调

独特：for of 不仅可以用于数组，也可以用于字符串，类数组对象
总结：for of 可以遍历数字下标的数组，类数组对象，字符串中的每个字符
for in 专门遍历自定义下标的关联数组和对象

4，参数增强
什么是参数增强： ES6 中对函数的参数提供了更强大，更方便的功能
1，参数默认值
function funname(形参 1，形参 2，..形参 n=默认值){
// 将来，如果调用函数时，传入最后一个参数，则使用用户传入的参数值，如果没有传入最后一个参数，则是哟个默认值
}

如果出现兼容问题 使用 ES5 替代
参数=参数值||默认值；
局限： 只能给最后一个参数设置默认值

2，剩余参数（rest）;
什么是剩余参数： 用来替代 arguments
为什么替代：
1，arguments 是类数组对象，不是纯正的数组，不能使用数组中的方法
2，在箭头函数中，不支持 arguments
3，arguments 只能获取全部的实参，不能选择性的获取部分参数

如何写
在定义函数时，除了已经给出的形式参数接受，剩余一部分有...数组名来接受
function name（uname,...money）{// ...不是省略形参，是语法结构
...是用来接受除了形参剩余的参数
money 是纯正的数组
即使改成箭头函数也支持
}
什么时候使用： 今后只要想替代 arguments 就可以使用剩余参数语法

3，打散数组
什么是打散数组：将一个数组中的元素一个一个单独拆开
为什么： 替代 apply
apply 的问题： apply 的本质工作不是打散数组，是专门用来替换 this，顺便打散数组
上面的 rest 语法不仅可以接受形参之外剩余的参数，还具备打散功能
fun(...arr)
先将 arr 数组中的元素打散，在依次传值给 fun

5,解构
什么是解构：将一个大的对象或者数组中的个别属性或者方法单独取出来，单独使用
什么时候使用： 如果给的是一个巨大的对象，而我们只需要其中的个别属性或者方法，可以把这个对象解构。
如何：
1，数组解构
将大数组中的某些元素单独提取出来使用
下标对应下标
[变量 1，变量 2....] = [1,2,3,4,5];
0 1 0 1 2 3
结果 变量 1=数组[0]
如果中间某些变量不需要提取，用,替代
[变量 1,,变量 3]=[1,2,3,4,5]
2,对象解构
什么：把对象的某些属性和方法单独取出来
如何：属性名对应属性名
var {属性名 1:变量 1,属性名 2:变量 2}=对象
简写 var {属性名 1,属性名 2}=对象
调用的时候
属性名 1（）；
属性名 2（）；

3,参数结构
1，函数参数可以写对象，并且可以指定对象属性默认值

6， 简化
ES6 在面向对象上做了简化
1，面向对象提供了两处简化
1，如果对象属性值来自于对象外部的变量，且变量名刚好和属性名相同，不用写两边相同的名字
2，所有的对象的方法，不需要写 function
强调： 对象中的方法去掉 function，不等效箭头函数，只是简写

2，class 类
what：集中定义对象属性的程序结构
为什么： 每一个对象都有两个组成部分，一个是构造方法，一个是原型对象，在书写的时候不是一个整体
1，把构造函数和原型方法放到用 class{}包裹起来
2，构造方法名提升为 class 名,构造方法统一改成 constructor
3，原型对象中的方法，不需要写构造 方法名.prototype



call,apply,bind: 替换 this
何时： 只要函数中带的 this 不是我们想要的，就可以用这个三个函数替换成我们想要的指向
如何：
1，call，apply： 只是在这一次调用的时候，临时将 this 指向这个对象，
要调用的函数.call(对象,参数 1，参数 2)
强调： 实参必须从第二个位置开始，第一个位置是我们想让 this 指向的对象名
call 更强大的地方是，可以让对象调用家族中不存在的函数
apply 和 call 的差别
call 在传递参数的时候，函数参数传值是一个一个的传
apply 中在传递参数的时候，函数的参数是传递一个数组，apply 增加了一个把数组打散在传递的功能

call 和 apply 只能临时绑定指向，如果多次调用，都需要多次绑定，很麻烦，bind 可以永久绑定
bind： 不调用函数，把原函数复制一份，this 永久的替换为绑定的这个对象
何时： 只要一个不想干的函数，需要反复调用，就是用 bind
如何
var 新函数名 = 旧函数.bind(替换 this 的对象,要绑定的实参值)
结果：
1，新函数的功能和就函数完全一样
2，新函数的 this 和 bind(对象，参数)的参数，永久固定
3，在调用的时候，只需要传递可变化的参数即可

  <!-- jisuan(name,base,jiang1,jiang2) -->
